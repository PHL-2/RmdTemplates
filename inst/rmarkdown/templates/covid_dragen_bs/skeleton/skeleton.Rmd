---
title: |
  ![](../aux_files/forKnitting/logo_blk.png){width=5in}  
  `r paste0('Sequencing run QC report')`
author: "Philadelphia Public Health Labs"
date: \today
geometry: margin=3cm
output: 
    pdf_document:
        template: ../aux_files/forKnitting/toc_after.tex
        keep_tex: false
        toc: true
        toc_depth: 3
        includes:
            in_header: ../aux_files/forKnitting/TeX_packages_commands.sty

---

\tableofcontents

```{r only run this chunk once to install, eval=FALSE}
### ================
### packages install
### ================
install.packages(c("knitr", "here", "tidyverse", "rvest", "pander", "kableExtra", "RColorBrewer", "readxl", "patchwork"))

```

<!-- ========================================================== -->
<!--   Beginning of Preamble : Preamble seldom requires change  -->
<!-- ========================================================== -->

```{r setup, echo=FALSE}
### ================
###   knitr setup
### ================
library(knitr)
opts_chunk$set(
  tidy=FALSE,
  cache=FALSE,
  cache.lazy = FALSE,
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  dpi=100,
  fig.width=6,
  fig.height=6,
  dev.args = list(pdf = list(useDingbats = FALSE))
  )

pander::panderOptions("knitr.auto.asis", FALSE)
#this also means that you have to put results='asis' in any block that has pander output
#this lets you loop through variables and produce multiple pander tables and ggplots in a
#single code block!

```

```{r generate SampleSheet and metadata, eval = FALSE}

source("metadata/munge/generate_barcodes_IDT.R")

```

```{r child = 'Rmd/preamble.Rmd'}
```


```{r versions check}
### ===========================
###   check version input
### ===========================
  
if (date_pipeline_was_run == "") {
  stop (simpleError("Please enter the date that the DRAGEN COVID Lineage App was run under the [date_pipeline_was_run] variable in the preamble"))
} else if (is.na(as.Date(date_pipeline_was_run, "%Y-%m-%d")) | nchar(date_pipeline_was_run) == 8) {
  stop (simpleError("Please enter the date into [date_pipeline_was_run] as YYYY-MM-DD"))
}

if (dragen_covid_lineage_version == "") {
  stop (simpleError("Please input the version of the DRAGEN COVID Lineage App under [dragen_covid_lineage_version] in the preamble.
                    This number can be found in the summary report page."))
} else if (!grepl("^[0-9]+\\.[0-9]+\\.[0-9]+$", dragen_covid_lineage_version)) {
  stop (simpleError("Please enter the version number into [dragen_covid_lineage_version] as N.N.N"))
}

if (nextclade_version == "") {
  stop (simpleError("Please input the version of Nextclade under [nextclade_version] in the preamble"))
} else if (!grepl("^[0-9]+\\.[0-9]+\\.[0-9]+$", nextclade_version)) {
  stop (simpleError("Please enter the version number into [nextclade_version] as N.N.N"))
}

if (is.na(primer_select) | is.na(artic_primer_scheme) | is.na(bs_bed_file_used)) {
  stop (simpleError("Please set the [primer_select] variable in the preamble as an integer from 1 to 3 according to the ARTIC primer scheme used for the library generation\n1: V3\n2: V4\n3: V4.1 (Experimental)"))
}

```

```{r samples check}

### possible issue 1: Samples found in the sample sheet but not in the results csv
s_missing <- s %>%
  filter(!sample_id %in% unique(bs_results$sample_id)) %>%
  select(sample_id, sample_type, isControl) %>%
  filter(sample_id != "None")

if (any(!s_missing$isControl)) {
  pander(filter(s_missing, !isControl), caption="These samples were in the sample sheet but had no results.")
  #stop (simpleError("Please fix"))
}

```

```{r Samples error check 2}
### possible issue 2: Samples found in the results csv but not in the sample sheet. There must be an error!
in_results_not_in_s <- setdiff(unique(bs_results$sample_id), s$sample_id)
if (length(in_results_not_in_s) > 0) {
  stop (simpleError("These SampleID(s) are in the results csv, but not found in the sample sheet.", paste(in_results_not_in_s, collapse=" ")))
}
```

\newpage

# Introduction

This report summarizes the results of `r nrow(s)-1` COVID samples sequenced on `r samp_sh_header$Date` and analyzed with BaseSpace DRAGEN Lineage App version `r dragen_covid_lineage_version` on `r date_pipeline_was_run`. The results section contains lineage and clade information using panogolin version `r panogolin_database_version` (https://cov-lineages.org/resources/pangolin.html) and Nextclade version `r nextclade_version` (https://clades.nextstrain.org/)

# Number of samples sequenced

```{r samples sequenced}

s %>%
  filter(sample_type != "Unassigned reads") %>%
  droplevels() %>%
  group_by(sample_type) %>%
  summarize(num = n()) %>%
  ungroup() %>%
  rename(`Sample Type` = "sample_type", n = "num") %>%
  kable_style()

```

\newpage

# FASTQ generation, demultiplexing, and quality control

<!-- ## bcl2fastq -->

<!-- BaseSpace uses the bcl2fastq command to generate FASTQ files from BCL files (raw data files that contain sequence information and quality scores). bcl2fastq version `bcl2fq_version` was used to generate the FASTQ files using the command: \newline -->
<!-- `r #bcl2fq_flags` -->

## GenerateFASTQ

The MiSeq machine uses the GenerateFASTQ workflow to demultiplex the samples and generate FASTQ files from BCL files (raw data files that contain sequence information and quality scores). `r workflow_name` version `r gen_fq_version` was used to generate the FASTQ files

## Number of read pairs per sample after demultiplexing

Samples were sequenced on the `r samp_sh_header$instrument_type` as a `r paste0(unlist(sample_sheet$Reads), collapse = ":")` length run and demultiplexed on BaseSpace by the GenerateFASTQ module. The demultiplexing step involves matching the IDT barcode sequence associated with each sample to the index sequence of each read

### Number of samples and their pass filter percentages

```{r percent of reads that passed filter, echo=FALSE}
s %>%
  mutate(pf_percent=read_counts/total_raw_reads) %>%
  ggplot(aes(x=pf_percent, fill = sample_type)) +
    geom_histogram(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    scale_x_continuous(labels = scales::percent) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Percent of reads that passed filter",
      y="Number of samples", fill = "Sample Type"
    )
```

### Distributions of reads across all samples

```{r reads_histogram, echo=FALSE}
s %>%
  mutate(num_seq=read_counts/1000000) %>%
  # remove reads that did not get assigned
  ggplot(aes(x=num_seq, fill = sample_type)) +
    geom_histogram(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Number of read pairs in sample (millions, M)",
      y="Number of samples",
      fill = "Sample Type"
    )
```

### Number of reads per sample type

```{r reads per sample type}

s %>%
  ggplot(aes(y=read_counts, x=sample_type, fill = sample_type)) +
    geom_boxplot() +
    geom_point(shape = 21, position = position_jitter(width = 0.2)) +
    scale_y_continuous(labels = scales::number_format(accuracy = 1)) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text.x.bottom = element_text(angle = -30, hjust = 0, vjust = 0.5)) +
    labs(
      y="Read counts",
      x="", fill = "Sample Type"
    )

```

### Percentage of reads that make up the lane

```{r percent reads of lane, echo=FALSE}
reads_percent <- s %>%
  mutate(percent_of_lane = read_counts/sum(read_counts)) %>%
  group_by(sample_type) %>%
  mutate(tot_percent = sum(percent_of_lane)) %>%
  ungroup() %>%
  order_on_other_col(sample_type, tot_percent, decreasing = FALSE) %>%
  order_on_other_col(sample_id, percent_of_lane) %>%
  arrange(sample_id)

reads_percent %>%
  ggplot(aes(x = "", y = percent_of_lane, fill=sample_type)) +
    geom_col(color = "white") +
    scale_y_continuous(labels = scales::percent) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(reads_percent$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.ticks.x.bottom = element_blank()) +
    labs(
      x="",
      y="Percent of assigned reads by sample type",
      fill = "Sample Type"
    )

```

## Top 10 unassigned indices

```{r unassigned indices}

top_unkwn_indices %>%
  ggplot(aes(y=fct_rev(index_sequence), x=number_of_reads)) +
  geom_col() +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(
      x="Number of reads",
      y="Unassigned index sequences"
  )

```

These are the adapters: \newline
`r paste0(gsub(",", ": ", unlist(sample_sheet$Settings)), collapse = "\n")`

\blandscape

## Read counts and the DNA concentration/viral values of each sample

```{r reads and CT, fig.width=10, fig.height=5, eval = has_CT}

s %>%
  ggplot(aes(x = CT, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "CT value", fill = "Sample type")

```

```{r reads and RLU, fig.width=10, fig.height=5, eval = has_RLU}

s %>%
  ggplot(aes(x = RLU, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "RLU value", fill = "Sample type")

```

```{r reads and DNA, fig.width=10, fig.height=5}

s %>%
  ggplot(aes(x = qubit_conc_ng_ul, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "DNA conc (ng/uL)", fill = "Sample type")

```

```{r CT and DNA, fig.width=10, fig.height=5, eval = has_CT}

s %>%
  ggplot(aes(x = CT, y = qubit_conc_ng_ul, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(x = "CT value", y = "DNA conc (ng/uL)", fill = "Sample type")

```

```{r RLU and DNA, fig.width=10, fig.height=5, eval = has_RLU}

s %>%
  ggplot(aes(x = RLU, y = qubit_conc_ng_ul, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(x = "RLU value", y = "DNA conc (ng/uL)", fill = "Sample type")

```
\newpage

## DNA concentration and read counts values per plate

The samples are processed on a 96-well plate. These figures illustrate the viral values, DNA concentration, and read counts of each sample on a well. Wells without any samples are white while samples with low values begin with dark blue. 

```{r CT on plate, eval = has_CT}
empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = CT)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no covid quantity values, use the discrete fill
    {
      if(all(is.na(s$CT))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="CT values"
    )

```

```{r RLU on plate, eval = has_RLU}
empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = RLU)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no covid quantity values, use the discrete fill
    {
      if(all(is.na(s$RLU))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="RLU values"
    )

```

```{r DNA on plate}

empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = qubit_conc_ng_ul)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no DNA concentration, use the discrete fill
    {
      if(all(is.na(s$qubit_conc_ng_ul))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="DNA\nconcentration\n(ng/ul)"
    )
```

```{r reads on plate}
empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = read_counts)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    scale_fill_viridis_c(na.value = "white") +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="Raw\nread\ncounts"
    )
```

\elandscape

# Results section

DRAGEN COVID Lineage App (on BaseSpace cloud) version `r dragen_covid_lineage_version` \newline
Panogolin database version `r panogolin_database_version` \newline
Lineage assignment software and version `r lineage_assignment_software_version`

## Kmer results (number of unique SARS-CoV-2 fragments detected)

```{r kmer numbers}

s %>%
  ggplot(aes(x=`SARS-CoV-2`, y = `SARS-CoV-2 Unique matching kmers`, fill = sample_type)) +
    geom_boxplot(outlier.alpha = 0) +
    geom_point(position = position_jitterdodge(), shape = 21) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="COVID detection",
      y="SARS-CoV-2\nkmer counts", fill = "Sample Type"
    )

```

## Kmer results (percentage of reference SARS-CoV-2 fragments detected)

```{r COVID detection}

s %>%
  ggplot(aes(x=`SARS-CoV-2 Fraction kmers detected`, fill = sample_type)) +
    geom_histogram(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    scale_x_continuous(labels=scales:::percent) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Percent of SARS-CoV-2\nfragments detected",
      y="Number of samples", fill = "Sample Type"
    )

```

## Pangolin Lineage Results

### Coverage

```{r pango coverage results}
s_toPlot %>%
  select(sample_type, coverage, `Coverage >= 30x`) %>%
  rename(cov_percent = "Coverage >= 30x") %>%
  mutate(coverage = as.numeric(gsub(".$", "", coverage))) %>%
  mutate(cov_percent = as.numeric(gsub(".$", "", cov_percent))/100) %>%
  ggplot(aes(x = coverage, y = cov_percent, fill = sample_type)) +
    geom_point(shape = 21) +
    scale_y_continuous(labels=scales:::percent) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s_toPlot$sample_type), names(ann_colors$sample_type))]) +
      theme_classic() +
      theme(
        strip.background = element_rect(color = "white", size = 50)
        ) +
      labs(x="Median coverage", y="Percentage of genome\nwith >= 30X coverage", fill="Sample Type") +
      guides(fill = guide_legend(reverse=T, order = 1))

```

\newpage

### Variant assignments

```{r variant assignments, fig.height=9, fig.width=7}
s_toPlot %>%
  select(sample_id, lineage, sample_type) %>%
  group_by(sample_type) %>%
  mutate(fraction = 1/n()) %>%
  ungroup() %>%
  mutate(variants = fct_lump(lineage, 10, w = fraction)) %>% 
  select(-lineage) %>%
  group_by(sample_type, variants) %>%
  summarize(props = sum(fraction)) %>%
  ungroup() %>%
  mutate(variants = factor(variants, levels = names(ann_colors$variants))) %>%
  {
  ggplot(., aes(x=sample_type, y=props, fill=variants)) +
    geom_bar(stat="identity", position = position_fill(reverse = TRUE)) +
    facet_grid(.~sample_type, space="free", scales="free",
               labeller = labeller(.default = function(x) {gsub(" ", "\n", x)}, .multi_line = FALSE)) +
    scale_fill_manual(values = ann_colors$variants[match(levels(.$variants), names(ann_colors$variants))]) +
    scale_y_continuous(limits = c(0,1), expand=c(0,0), labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_rect(color = "white", size = 50),
      strip.text = element_text(size = 12),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      plot.title = element_text(hjust = 0.5)
      ) +
    labs(x="", y="Relative abundance", title = "Sample type", fill="Variants") +
    guides(fill = guide_legend(reverse=T, order = 1)) +
  who_legend
  }

```
\newpage

### Figure showing conflicting variant assignments from pUSHER, pangoLEARN, or scorpio

```{r multiple variant assignments, fig.height=9, fig.width=8}

s_toPlot %>%
  select(sample_id, Conflict, Note, sample_type, nc_QC_status, coverage_num) %>%
  #remove "Usher placements" text in the front of Note
  mutate(Note = gsub("^.*: ", "", Note)) %>%
  #split Note into two variant columns by the space
  separate(Note, into = c("variant1", "variant2"), sep = " ", extra = "merge") %>%
  mutate(variant1_prop = gsub(".*\\(|\\)", "", variant1)) %>%
  #if the notes say assigned, it means that PANGO software was used and found an exact match of the sequence to a representative lineage
  mutate(variant1_prop = gsub("Assigned from designation hash.", "1", variant1_prop)) %>%
  mutate(variant1_prop = unlist(lapply(variant1_prop, function(x) eval(parse(text=x))))) %>%
  mutate(variant1_prop = ifelse(grepl("scorpio lineage.*.conflicts.*", variant2), variant1_prop/2, variant1_prop)) %>%
  mutate(variant2_prop = gsub(".*\\(|\\)", "", variant2)) %>%
  #if the notes say scorpio has insufficient support, just ignore it and use the PUSHER/PLEARN assignments
  mutate(variant2_prop = gsub("scorpio found insufficient support.*", NA, variant2_prop)) %>%
  #if the notes say scorpio conflicts, include it in this figure
  mutate(variant2_prop = gsub("scorpio lineage.*.conflicts.*", variant1_prop, variant2_prop)) %>%
  mutate(variant2 = gsub("scorpio lineage | conflicts with inference lineage .*", "", variant2)) %>%
  mutate(variant2_prop = unlist(lapply(variant2_prop, function(x) eval(parse(text=x))))) %>%
  pivot_longer(cols = c("variant1_prop", "variant2_prop"), names_to = "variant_num", values_to = "props") %>%
  mutate(variants = case_when(variant_num == "variant1_prop" ~ gsub("\\(.*", "", variant1),
                             variant_num == "variant2_prop" ~ gsub("\\(.*", "", variant2),
                             TRUE ~ NA_character_)) %>%
  filter(!is.na(props)) %>%
  mutate(variants = factor(variants, levels = names(ann_colors$variants))) %>%
  mutate(nc_QC_status = factor(nc_QC_status, levels = c("good", "mediocre", "bad"))) %>%
  mutate(sample_id = factor(sample_id, levels = unique(sample_id[order(variants, decreasing = FALSE)]))) %>%
  {
  ggplot(., aes(x=props, y=sample_id, fill=variants)) +
    geom_bar(stat="identity", position = position_fill(reverse = TRUE)) +
    facet_grid(nc_QC_status+sample_type~., space="free", scales="free",
               labeller = labeller(.default = start_w_newline, .multi_line = FALSE)) +
    scale_fill_manual(values = ann_colors$variants[match(levels(.$variants), names(ann_colors$variants))]) +
    scale_x_continuous(limits = c(0,1), expand=c(0,0), labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_blank(),
      strip.text.y = element_text(angle = 0, size = 6)
      ) +
    labs(y="", x="Relative abundance", fill="Variants") +
    guides(fill = guide_legend(reverse=T, order = 1)) +
  who_legend
  }

```

```{r lineage and VOC checks}

has_pos_ctrl <- s %>%
  filter(grepl("Mock DNA", sample_type)) %>%
  mutate(is_pos = lineage == "B") %>%
  select(is_pos) %>%
  pull()

not_same_VOCs <- s %>%
  mutate(compare = n_VOC != scorpio) %>%
  filter(!is.na(compare)) %>%
  select(compare) %>%
  pull() %>%
  sum()

```

`r if(!has_pos_ctrl){paste0("\\textcolor{red}{\\huge Positive control is not correct lineage}")}`

`r if(not_same_VOCs > 0){paste0("Number of NextClade VOC and scorpio constellation mismatches: ", not_same_VOCs)}`

## Nextclade

### Coverage and QC scores

```{r nextclade coverage, fig.height=9, fig.width=7}
s_toPlot %>%
  select(sample_type, coverage, `Coverage >= 30x`, nc_QC_status) %>%
  filter(!is.na(coverage)) %>%
  rename(cov_percent = "Coverage >= 30x") %>%
  mutate(coverage = as.numeric(gsub(".$", "", coverage))) %>%
  mutate(cov_percent = as.numeric(gsub(".$", "", cov_percent))/100) %>%
  mutate(nc_QC_status = factor(nc_QC_status, levels = c("good", "mediocre", "bad"))) %>%
  ggplot(aes(x = nc_QC_status, y = cov_percent)) +
    geom_hline(slope = 0, yintercept = 0.8, color = "grey", linetype = "dotted", lwd=0.75) +
    geom_boxplot(outlier.alpha = 0) +
    geom_point(aes(fill = coverage, shape = sample_type), position = position_jitterdodge(), size = 3) +
    scale_shape_manual(values = 21:(21+length(ann_colors$sample_type))) +
    scale_fill_viridis_c() +
    scale_y_continuous(labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_rect(color = "white", size = 50)
    ) +
    labs(x="NextClade QC Status", y="Percentage of genome\nwith >= 30X coverage", fill = "Median\nCoverage (X)", shape = "Sample Type")

```

### Mutations

```{r mutations}

```

```{r data export}
dir.create(here("upload", "epi"), recursive = TRUE)
dir.create(here("upload", "gisaid"), recursive = TRUE)
dir.create(here("upload", "sra"), recursive = TRUE)

# Export the data for EPI's
epi_report <- s_toPlot %>%
  #filter out controls
  filter(!grepl("control", sample_type, ignore.case = TRUE)) %>%
  #filter out bad results
  filter(nc_QC_status != "bad") %>%
  #filter out mediocre results with lower coverages
  filter(!(nc_QC_status == "mediocre" & coverage_num < 80)) %>%
  select(sample_name, sample_collected_by, sequencing_date, lineage, scorpio) %>%
  arrange(sample_collected_by, sample_name) %>%
  rename(accession_number = "sample_name", who_label = "scorpio")

epi_report %>%
  write_csv(here("upload", "epi", paste(sequencing_run_date, project_name, "PHL_sequencing_results.csv", sep = "_")))

# Export the data for GISAID upload
gisaid <- s_toPlot %>%
  #filter out controls
  filter(!grepl("control", sample_type, ignore.case = TRUE)) %>%
  #filter out bad results
  filter(nc_QC_status != "bad") %>%
  #filter out mediocre results with lower coverages
  filter(!(nc_QC_status == "mediocre" & coverage_num < 80)) %>%
  mutate(`Virus name` = paste0("hCoV-2/USA/", sample_id, "/", str_sub(sequencing_run_date, 1, 4))) %>%
  mutate(Type = "betacoronavirus", `Passage details/history` = "Original", Location = "North America/USA/Pennsylvania",
         `Patient age` = "Unknown", `Patient status` = "Unknown", `Sequencing technology` = paste0("Illumina ", instrument_type),
         `Assembly method` = paste0("DRAGEN COVID Lineage ", dragen_covid_lineage_version),
         `Submitting lab` = "Philadelphia Department of Public Health",
         Address = "500 S. Broad Street, Philadelphia, PA 19146 USA") %>%
  mutate(Host = ifelse(host_scientific_name == "Homo sapiens", "Human", NA)) %>%
  rename(`Collection date` = "sample_collection_date", Gender = "gender", Coverage = "coverage", `Originating lab` = "sample_collected_by", `Specimen source` = "sample_type") %>%
  select(`Virus name`, Type, `Passage details/history`, `Collection date`, Location, Host, Gender, `Patient age`, `Patient status`,
         `Specimen source`, `Sequencing technology`, `Assembly method`, Coverage, `Originating lab`, `Submitting lab`, Address)

gisaid %>%
  write_csv(here("upload", "gisaid", paste(sequencing_run_date, project_name, "PHL2_GISAID_upload.csv", sep = "_")))

# Export the data for SRA upload
bio_sample <- s_toPlot %>%
  #filter out controls
  filter(!grepl("control", sample_type, ignore.case = TRUE)) %>%
  #filter out bad results
  filter(nc_QC_status != "bad") %>%
  #filter out mediocre results with lower coverages
  filter(!(nc_QC_status == "mediocre" & coverage_num < 80)) %>%
  select(-c(sample_name)) %>%
  mutate(isolate = paste0("SARS-CoV-2/USA/", sample_id, "/", str_sub(sequencing_run_date, 1, 4))) %>%
  mutate(GISAID_virus_name = paste0("hCoV-2/USA/", sample_id, "/", str_sub(sequencing_run_date, 1, 4))) %>%
  mutate(geo_loc_name = "USA: PA", sequenced_by = "phl.sequencing@phila.gov", purpose_of_sampling = "Surveillance [GENEPIO:0100004]",
         isolation_source = paste0(isolation_source, "; See additional sample source fields for further information")) %>%
  rename(sample_name = "sample_id", collected_by = "sample_collected_by", collection_date = "sample_collection_date",
         host_age = "host_age_bin", host = "host_scientific_name", host_sex = "gender") %>%
  select(sample_name, organism, isolate, collected_by, collection_date, geo_loc_name, GISAID_virus_name, sequenced_by,
         purpose_of_sampling, isolation_source, collection_device,
         host_age, host, host_disease, host_sex)

bio_sample %>%
  write_csv(here("upload", "sra", paste(sequencing_run_date, project_name, "PHL2_BioSample_upload.csv", sep = "_")))

# Export the data for SRA upload
sra <- s_toPlot %>%
  #filter out controls
  filter(!grepl("control", sample_type, ignore.case = TRUE)) %>%
  #filter out bad results
  filter(nc_QC_status != "bad") %>%
  #filter out mediocre results with lower coverages
  filter(!(nc_QC_status == "mediocre" & coverage_num < 80)) %>%
  mutate(Title = paste0("Sequencing of ", tolower(organism), " from ", tolower(sample_type))) %>%
  mutate(design_description = paste0("Viral sequencing was performed following a tiling amplicon strategy using the ARTIC V4 primer scheme. Sequencing was performed using the Illumina MiSeq instrument with 2x", read_length, " bp chemistry. Libraries were prepared using Illumina COVIDSeq Test kit.")) %>%
  mutate(Filename = paste0(sample_id, "_S", SampleNumber, "_L00", lane, "_R1_001.fastq.gz")) %>%
  mutate(Filename2 = paste0(sample_id, "_S", SampleNumber, "_L00", lane, "_R2_001.fastq.gz")) %>%
  mutate(Platform = "ILLUMINA", instrument_model = paste0("Illumina ", instrument_type), library_strategy = "AMPLICON",
         library_source = "Viral RNA", library_selection = "PCR", library_layout = "PAIRED", Filetype = "fastq",
         sequencing_protocol_name = "ARTIC Network Protocol V4",
         raw_sequence_data_processing_method = paste0("DRAGEN COVID Lineage ", dragen_covid_lineage_version),
         sequence_submitter_contact_email = "phl.sequencing@phila.gov") %>%
  rename(Library_ID = "sample_id") %>%
  select(Library_ID, Title, Platform, instrument_model, library_strategy, library_source, library_selection, library_layout, design_description,
         Filetype, Filename, Filename2, sequencing_protocol_name, raw_sequence_data_processing_method, sequence_submitter_contact_email)

sra %>%
  write_csv(here("upload", "sra", paste(sequencing_run_date, project_name, "PHL2_BioSample_upload.csv", sep = "_")))

#just a check to see if number of samples match
n_samples_report <- s %>%
  filter(!grepl("None|Undetermined", sample_id)) %>%
  filter(!grepl("control", sample_type, ignore.case = TRUE)) %>%
  filter(!is.na(lineage)) %>%
  filter(!is.na(nc_QC_status)) %>%
  filter(nc_QC_status != "bad") %>%
  filter(!(nc_QC_status == "mediocre" & coverage_num < 80)) %>%
  nrow()

```

\newpage

# Appendix

## Number of reads before and after filtering
Red samples refer to results that will not be reported (controls or no lineage results) \newline
Orange samples also refer to results that will not be reported (bad or mediocre NextClade QC with <80% 30X coverage) \newline
The total number of samples with acceptable results for reporting is `r n_samples_report` out of `r nrow(s[grepl("Nasal swab", s$sample_type), ])` nasal samples sequenced

```{r trimmed reads, echo=FALSE}

s %>%
  arrange(-read_counts) %>%
  mutate(sample_id = cell_spec(sample_id, "latex",
                               color = case_when(((grepl("control|Unassigned reads", sample_type)) | (!(sample_id %in% s_toPlot$sample_id))) ~ "red",
                                                 ((grepl("bad", nc_QC_status)) | (grepl("mediocre", nc_QC_status) & coverage_num < 80)) ~ "orange",
                                                 TRUE ~ "black"))) %>%
  select(sample_id,
         sample_type,
         total_raw_reads,
         read_counts) %>%
  kable_style()
```

```{r Generate time stamped report, eval=FALSE, include=FALSE}
#notes
#neat: you can run this following command in the console to give your reports custom names (or date-stamp them)
#rmarkdown::render('ronen_stein_Report_shotgun.Rmd',output_file = paste('CEASE.report.', Sys.Date(), '.pdf', sep=''))
library(here)
rstudioapi::documentSaveAll()
dir.create(here("output"))

sequencing_run_date <- gsub("_.*", "", basename(here()))
project_name <- sub("^([^_]+)_", "", basename(here()), perl = TRUE)

qc_report_fp <- paste(sequencing_run_date, "_" , project_name, "_QC_Report.Rmd", sep="")
qc_output_fp <- here("output", paste(sequencing_run_date, "_", project_name, '.QC.report_gen.on.', Sys.Date(), '.pdf', sep=''))

rmarkdown::render(qc_report_fp, output_file = qc_output_fp)
rmarkdown::render(qc_report_fp, output_file = "README.md",
                  output_format = rmarkdown::md_document(variant = "markdown_github", toc = TRUE))

#save some files if this script exists
tryCatch(
  {
    source(gsub(basename(here()), "cp2admin.R", here()))
  }, error = function(e) 
  {
    
  }
)

```
