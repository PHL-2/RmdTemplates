---
title: |
  ![](forKnitting/logo_blk.png){width=5in}  
  "`r paste0('Sequencing run QC report')`"
author: "Philadelphia Public Health Labs"
date: \today
geometry: margin=3cm
output: 
    pdf_document:
        template: forKnitting/toc_after.tex
        keep_tex: false
        toc: true
        toc_depth: 3
        includes:
            in_header: forKnitting/TeX_packages_commands.sty

---

\tableofcontents

```{r only run this chunk once to install, eval=FALSE}
### ================
### packages install
### ================
install.packages(c("knitr", "here", "tidyverse", "rvest", "pander", "kableExtra", "RColorBrewer", "readxl", "patchwork"))

```

<!-- ========================================================== -->
<!--   Beginning of Preamble : Preamble seldom requires change  -->
<!-- ========================================================== -->

```{r setup, echo=FALSE}
### ================
###   knitr setup
### ================
library(knitr)
opts_chunk$set(
  tidy=FALSE,
  cache=FALSE,
  cache.lazy = FALSE,
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  dpi=100,
  fig.width=6,
  fig.height=6,
  dev.args = list(pdf = list(useDingbats = FALSE))
  )

pander::panderOptions("knitr.auto.asis", FALSE)
#this also means that you have to put results='asis' in any block that has pander output
#this lets you loop through variables and produce multiple pander tables and ggplots in a
#single code block!

```

```{r generate SampleSheet and metadata, eval = FALSE}

source('metadata/munge/generate_barcodes_IDT.R')

```

```{r child = 'Rmd/preamble.Rmd'}
```


```{r versions check}
### ===========================
###   check version input
### ===========================
  
if (date_pipeline_was_run == "") {
  stop (simpleError("Please enter the date that the DRAGEN COVID Lineage App was run under the [date_pipeline_was_run] variable in the preamble"))
} else if (is.na(as.Date(date_pipeline_was_run, "%Y-%m-%d")) | nchar(date_pipeline_was_run) == 8) {
  stop (simpleError("Please enter the date into [date_pipeline_was_run] as YYYY-MM-DD"))
}

if (dragen_covid_lineage_version == "") {
  stop (simpleError("Please input the version of the DRAGEN COVID Lineage App under [dragen_covid_lineage_version] in the preamble.
                    This number can be found in the summary report page."))
} else if (!grepl("^[0-9]+\\.[0-9]+\\.[0-9]+$", dragen_covid_lineage_version)) {
  stop (simpleError("Please enter the version number into [dragen_covid_lineage_version] as N.N.N"))
}

if (nextclade_version == "") {
  stop (simpleError("Please input the version of Nextclade under [nextclade_version] in the preamble"))
} else if (!grepl("^[0-9]+\\.[0-9]+\\.[0-9]+$", nextclade_version)) {
  stop (simpleError("Please enter the version number into [nextclade_version] as N.N.N"))
}

if (is.na(primer_select) | is.na(artic_primer_scheme) | is.na(bs_bed_file_used)) {
  stop (simpleError("Please set the [primer_select] variable in the preamble as an integer from 1 to 3 according to the ARTIC primer scheme used for the library generation\n1: V3\n2: V4\n3: V4.1 (Experimental)"))
}

```

```{r samples check}

### possible issue 1: Samples found in the sample sheet but not in the results csv
s_missing <- s %>%
  filter(!sample_id %in% unique(bs_results$sample_id)) %>%
  select(sample_id, sample_type, isControl) %>%
  filter(sample_id != "None")

if (any(!s_missing$isControl)) {
  pander(filter(s_missing, !isControl), caption="These samples were in the sample sheet but had no results.")
  #stop (simpleError("Please fix"))
}

```

```{r, Samples error check 2}
### possible issue 2: Samples found in the results csv but not in the sample sheet. There must be an error!
in_results_not_in_s <- setdiff(unique(bs_results$sample_id), s$sample_id)
if (length(in_results_not_in_s) > 0) {
  stop (simpleError("These SampleID(s) are in the results csv, but not found in the sample sheet.", paste(in_results_not_in_s, collapse=" ")))
}
```

\newpage

# Introduction

This report summarizes the results of `r nrow(s)` COVID samples sequenced on `r samp_sh_header$Date` and analyzed with BaseSpace DRAGEN Lineage App version `r dragen_covid_lineage_version` on `r date_pipeline_was_run`. Results section contain lineage and clade information using panogolin version `r panogolin_database_version` (https://cov-lineages.org/resources/pangolin.html) and Nextclade version `r nextclade_version` (https://clades.nextstrain.org/)

# FASTQ generation, demultiplexing, and quality control

<!-- ## bcl2fastq -->

<!-- BaseSpace uses the bcl2fastq command to generate FASTQ files from BCL files (raw data files that contain sequence information and quality scores). bcl2fastq version `bcl2fq_version` was used to generate the FASTQ files using the command: \newline -->
<!-- `r #bcl2fq_flags` -->

## GenerateFASTQ

The MiSeq machine uses the GenerateFASTQ workflow to demultiplex the samples and generate FASTQ files from BCL files (raw data files that contain sequence information and quality scores). `r workflow_name` version `r gen_fq_version` was used to generate the FASTQ files

## Number of read pairs per sample after demultiplexing

Samples were sequenced on the `r samp_sh_header$instrument_type` as a `r paste0(unlist(sample_sheet$Reads), collapse = ":")` length run and demultiplexed on BaseSpace by the GenerateFASTQ module. The demultiplexing step involves matching the barcode sequences associated with each sample to the sequence each read is tagged with

```{r percent of reads that passed filter, echo=FALSE}
s %>%
  mutate(pf_percent=read_counts/total_raw_reads) %>%
  ggplot(aes(x=pf_percent, fill = sample_type)) +
    geom_histogram(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    scale_x_continuous(labels = scales::percent) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Percent of reads that passed filter",
      y="Number of samples", fill = "Sample Type"
    )
```

```{r reads_histogram, echo=FALSE}
s %>%
  mutate(num_seq=read_counts/1000000) %>%
  # remove reads that did not get assigned
  ggplot(aes(x=num_seq, fill = sample_type)) +
    geom_histogram(binwidth=0.5, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Number of read pairs in sample (millions, M)",
      y="Number of samples",
      fill = "Sample Type"
    )
```

```{r percent reads of lane, echo=FALSE}
reads_percent <- s %>%
  mutate(percent_of_lane = read_counts/sum(read_counts)) %>%
  group_by(sample_type) %>%
  mutate(tot_percent = sum(percent_of_lane)) %>%
  ungroup() %>%
  order_on_other_col(sample_type, tot_percent, decreasing = FALSE) %>%
  order_on_other_col(sample_id, percent_of_lane) %>%
  arrange(sample_id)

reads_percent %>%
  ggplot(aes(x = "", y = percent_of_lane, fill=sample_type)) +
    geom_col(color = "white") +
    scale_y_continuous(labels = scales::percent) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(reads_percent$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.ticks.x.bottom = element_blank()) +
    labs(
      x="",
      y="Percent of assigned reads by sample type",
      fill = "Sample Type"
    )

```

## Top 10 unassigned indices

```{r}

top_unkwn_indices %>%
  ggplot(aes(y=fct_rev(index_sequence), x=number_of_reads)) +
  geom_col() +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(
      x="Number of reads",
      y="Unassigned index sequences"
  )

```

These are the adapters: \newline
`r paste0(gsub(",", ": ", unlist(sample_sheet$Settings)), collapse = "\n")`

\blandscape

## Read counts and DNA concentration of each sample

```{r, fig.width=10, fig.height=5, eval = has_CT}

s %>%
  ggplot(aes(x = CT, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "CT value", fill = "Sample type")

```

```{r, fig.width=10, fig.height=5, eval = has_RLU}

s %>%
  ggplot(aes(x = RLU, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "RLU value", fill = "Sample type")

```

```{r, fig.width=10, fig.height=5}

s %>%
  ggplot(aes(x = qubit_conc_ng_ul, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "DNA conc (ng/uL)", fill = "Sample type")

```

```{r, fig.width=10, fig.height=5, eval = has_CT}

s %>%
  ggplot(aes(x = CT, y = qubit_conc_ng_ul, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(x = "CT value", y = "DNA conc (ng/uL)", fill = "Sample type")

```

```{r, fig.width=10, fig.height=5, eval = has_RLU}

s %>%
  ggplot(aes(x = RLU, y = qubit_conc_ng_ul, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(x = "RLU value", y = "DNA conc (ng/uL)", fill = "Sample type")

```
\newpage

## DNA concentration and read counts values per plate

The samples are processed on a 96-well plate. The figures illustrate the sample_information, DNA concentration, and read counts after demultiplexing. Wells without any samples are white while samples with low values begin with dark blue. 

```{r, eval = has_CT}
empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = CT)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no covid quantity values, use the discrete fill
    {
      if(all(is.na(s$qubit_conc_ng_ul))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="CT values"
    )

```

```{r, eval = has_RLU}
empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = RLU)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no covid quantity values, use the discrete fill
    {
      if(all(is.na(s$qubit_conc_ng_ul))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="RLU values"
    )

```

```{r}

empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = qubit_conc_ng_ul)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no DNA concentration, use the discrete fill
    {
      if(all(is.na(s$qubit_conc_ng_ul))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="DNA\nconcentration\n(ng/ul)"
    )
```

```{r}
empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = read_counts)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    scale_fill_viridis_c(na.value = "white") +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="Raw\nread\ncounts"
    )
```

\elandscape

# Results section

DRAGEN COVID Lineage App (on BaseSpace cloud) version `r dragen_covid_lineage_version` \newline
Panogolin database version `r panogolin_database_version` \newline
Lineage assignment software and version `r lineage_assignment_software_version`

## Kmer results (number of unique COVID fragments detected)

```{r}

s_toPlot %>%
  ggplot(aes(x=`SARS-CoV-2`, fill = sample_type)) +
    geom_bar(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s_toPlot$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="COVID status",
      y="Number of samples", fill = "Sample Type"
    )

```

```{r}

s_toPlot %>%
  ggplot(aes(x=`SARS-CoV-2`, y = `SARS-CoV-2 Unique matching kmers`, fill = sample_type)) +
    geom_boxplot(outlier.alpha = 0) +
    geom_point(position = position_jitterdodge(), shape = 21) +
    scale_fill_manual(values = ann_colors$sample_type[match(levels(s_toPlot$sample_type), names(ann_colors$sample_type))]) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="COVID status",
      y="Unique kmer counts", fill = "Sample Type"
    )

```

## Pangolin Lineage Results

```{r}
s_toPlot %>%
  select(sample_id, lineage, sample_type) %>%
  group_by(sample_type) %>%
  mutate(fraction = 1/n()) %>%
  ungroup() %>%
  mutate(variants = fct_lump(lineage, 10, w = fraction)) %>% 
  select(-lineage) %>%
  group_by(sample_type, variants) %>%
  summarize(props = sum(fraction)) %>%
  ungroup() %>%
  mutate(variants = factor(variants, levels = names(ann_colors$variants))) %>%
  ggplot(aes(x=sample_type, y=props, fill=variants)) +
    geom_bar(stat="identity", position = position_fill(reverse = TRUE)) +
    facet_grid(.~sample_type, space="free", scales="free",
               labeller = labeller(.default = function(x) {gsub(" ", "\n", x)}, .multi_line = FALSE)) +
    scale_fill_manual(values = ann_colors$variants) +
    scale_y_continuous(limits = c(0,1), expand=c(0,0), labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_rect(color = "white", size = 50),
      strip.text = element_text(size = 12),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      plot.title = element_text(hjust = 0.5)
      ) +
    labs(x="", y="Relative abundance", title = "Sample type", fill="Variants") +
    guides(fill = guide_legend(reverse=T, order = 1)) +
  who_label_lab

```
\newpage

Samples with conflicts and ambiguity in variant assignments

```{r}
#this is a very long-winded way of calculating the conflicting variants. There should be shorter code
s_toPlot %>%
  select(sample_id, Conflict, Note, sample_type) %>%
  mutate(Note = gsub(".*: ", "", Note)) %>%
  separate(Note, into = c("variant1", "variant2"), sep = " ", extra = "merge") %>%
  mutate(variant1_prop = gsub(".*\\(|\\)", "", variant1)) %>%
  #not sure what this text means
  filter(!grepl("Assigned", variant1_prop)) %>%
  mutate(variant1_prop = unlist(lapply(variant1_prop, function(x) eval(parse(text=x))))) %>%
  mutate(variant2_prop = gsub(".*\\(|\\)", "", variant2)) %>%
  filter(!grepl("scorpio", variant2_prop)) %>%
  mutate(variant2_prop = unlist(lapply(variant2_prop, function(x) eval(parse(text=x))))) %>%
  pivot_longer(cols = c("variant1_prop", "variant2_prop"), names_to = "variant_num", values_to = "props") %>%
  mutate(variants = case_when(variant_num == "variant1_prop" ~ gsub("\\(.*", "", variant1),
                             variant_num == "variant2_prop" ~ gsub("\\(.*", "", variant2),
                             TRUE ~ NA_character_)) %>%
  filter(!is.na(props)) %>%
  mutate(variants = factor(variants, levels = names(ann_colors$variants))) %>%
  order_on_other_col(sample_id, variants, decreasing = F) %>%
  ggplot(aes(x=props, y=sample_id, fill=variants)) +
    geom_bar(stat="identity", position = position_fill(reverse = TRUE)) +
    facet_grid(.~sample_type, space="free", scales="free",
               labeller = labeller(.default = function(x) {gsub(" ", "\n", x)}, .multi_line = FALSE)) +
    #facet_grid(sample_type~., space="free", scales="free",
    #           labeller = labeller(.default = start_w_newline, .multi_line = FALSE)) +
    scale_fill_manual(values = ann_colors$variants) +
    scale_x_continuous(limits = c(0,1), expand=c(0,0), labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_blank(),
      strip.text.y = element_text(angle = 0)
      ) +
    labs(y="", x="Relative abundance", fill="Variants") +
    guides(fill = guide_legend(reverse=T, order = 1)) +
  who_label_lab

```

## Nextclade assignments

```{r}

```

\newpage

# Appendix

## Number of reads before and after filtering

```{r trimmed reads, echo=FALSE}

s %>%
  arrange(-read_counts) %>%
  select(sample_id,
         sample_type,
         total_raw_reads,
         read_counts) %>%
  kable_style()
```

```{r data export}
dir.create(here("epi"))

# Export the data for EPI's
s_toPlot %>%
  filter(!grepl("control", sample_type, ignore.case = TRUE)) %>%
  select(sample_name, sample_collected_by, sequencing_date, lineage, scorpio) %>%
  arrange(sample_collected_by, sample_name) %>%
  rename(accession_number = "sample_name", who_label = "scorpio") %>%
  write_csv(here("epi", paste(sequencing_run_date, project_name, "PHL_sequencing_results.csv", sep = "_")))

```

```{r Generate time stamped report, eval=FALSE, include=FALSE}
#notes
#neat: you can run this following command in the console to give your reports custom names (or date-stamp them)
#rmarkdown::render('ronen_stein_Report_shotgun.Rmd',output_file = paste('CEASE.report.', Sys.Date(), '.pdf', sep=''))
library(here)
rstudioapi::documentSaveAll()
dir.create(here("output", "basic_report"))

sequencing_run_date <- gsub("_.*", "", basename(here()))
project_name <- sub("^([^_]+)_", "", basename(here()), perl = TRUE)

qc_report_fp <- paste(sequencing_run_date, "_" , project_name, "_QC_Report.Rmd", sep="")
qc_output_fp <- here("output", "basic_report", paste(Sys.Date(), "_", project_name, '.QC.report.', sequencing_run_date, '.pdf', sep=''))

rmarkdown::render(qc_report_fp, output_file = qc_output_fp)
rmarkdown::render(qc_report_fp, output_file = "README.md",
                  output_format = rmarkdown::md_document(variant = "markdown_github", toc = TRUE))

```
