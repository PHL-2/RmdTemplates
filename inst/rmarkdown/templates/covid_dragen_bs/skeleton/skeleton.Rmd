---
title: |
  ![](../aux_files/forKnitting/logo_blk.png){width=5in}  
  `r paste0('QC report for sequencing run ', basename(here()))`
author: "Philadelphia Public Health Labs"
date: \today
geometry: margin=3cm
output:
    pdf_document:
        template: ../aux_files/forKnitting/toc_after.tex
        keep_tex: false
        toc: true
        toc_depth: 3
        includes:
            in_header: ../aux_files/forKnitting/TeX_packages_commands.sty

---

\tableofcontents

```{r only run this chunk once to install, eval=FALSE}
### ================
### packages install
### ================
install.packages(c("knitr", "here", "tidyverse", "rvest", "pander", "kableExtra", "RColorBrewer", "readxl", "patchwork"))

```

<!-- ========================================================== -->
<!--   Beginning of Preamble : Preamble seldom requires change  -->
<!-- ========================================================== -->

```{r setup, echo=FALSE}
### ================
###   knitr setup
### ================
library(knitr)
opts_chunk$set(
  tidy=FALSE,
  cache=FALSE,
  cache.lazy = FALSE,
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  dpi=100,
  fig.width=6,
  fig.height=6,
  dev.args = list(pdf = list(useDingbats = FALSE))
  )

pander::panderOptions("knitr.auto.asis", FALSE)
#this also means that you have to put results='asis' in any block that has pander output
#this lets you loop through variables and produce multiple pander tables and ggplots in a
#single code block!

```

```{r generate SampleSheet and metadata, eval = FALSE}

source("code/generate_barcodes_IDT.R")

```

```{r child = 'code/preamble.Rmd'}
```


```{r check if primer selected}
### ===========================
###   check version input
### ===========================
  
if (is.na(primer_select) | is.na(artic_primer_scheme) | is.na(bs_bed_file_used)) {
  stop (simpleError("Please set the [primer_select] variable in the preamble as an integer from 1 to 3 according to the ARTIC primer scheme used for the library generation\n1: V3\n2: V4\n3: V4.1 (Experimental)"))
}

```

```{r samples check}

### possible issue 1: Samples found in the sample sheet but not in the results csv
s_missing <- s %>%
  filter(!sample_id %in% unique(bs_results$sample_id)) %>%
  select(sample_id, sample_type, isControl) %>%
  filter(sample_id != "None")

if (any(!s_missing$isControl)) {
  pander(filter(s_missing, !isControl), caption="These samples were in the sample sheet but had no results.")
  #stop (simpleError("Please fix"))
}

```

```{r Samples error check 2}
### possible issue 2: Samples found in the results csv but not in the sample sheet. There must be an error!
in_results_not_in_s <- setdiff(unique(bs_results$sample_id), s$sample_id)
if (length(in_results_not_in_s) > 0) {
  stop (simpleError("These SampleID(s) are in the results csv, but not found in the sample sheet.", paste(in_results_not_in_s, collapse=" ")))
}
```

\newpage

# Introduction

This report summarizes the results of `r nrow(s)-1` COVID samples sequenced on `r samp_sh_header$Date` and analyzed with BaseSpace DRAGEN Lineage App version `r dragen_covid_lineage_version` on `r date_pipeline_was_run`. The results section contains lineage information using the pangolin software version `r pangolin_software_version` (https://cov-lineages.org/resources/pangolin.html) and Nextclade version `r nextclade_version` (https://clades.nextstrain.org/)

# Number of samples sequenced

```{r samples sequenced}

s %>%
  filter(sample_type != "Unassigned reads") %>%
  droplevels() %>%
  group_by(sample_type) %>%
  summarize(num = n()) %>%
  ungroup() %>%
  rename(`Sample Type` = "sample_type", n = "num") %>%
  kable_style()

```

\newpage

# FASTQ generation, demultiplexing, and quality control

## GenerateFASTQ

The MiSeq machine uses the GenerateFASTQ workflow to demultiplex the samples and generate FASTQ files from BCL files (raw data files that contain sequence information and quality scores). `r workflow_name` version `r gen_fq_version` was used to generate the FASTQ files

## Number of read pairs per sample after demultiplexing

Samples were sequenced on the `r samp_sh_header$instrument_type` as a `r paste0(unlist(sample_sheet$Reads), collapse = ":")` length run and demultiplexed on BaseSpace by the GenerateFASTQ module. The demultiplexing step involves matching the IDT barcode sequence associated with each sample to the index sequence of each read

### Number of samples and their pass filter percentages

```{r percent of reads that passed filter, echo=FALSE}
s %>%
  mutate(pf_percent=read_counts/total_raw_reads) %>%
  ggplot(aes(x=pf_percent, fill = sample_type)) +
    geom_histogram(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(s$sample_type), names(ann_geom_values$sample_type_colors))]) +
    scale_x_continuous(labels = scales::percent) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Percent of reads that passed filter",
      y="Number of samples", fill = "Sample Type"
    )
```

### Distributions of reads across all samples

```{r reads_histogram, echo=FALSE}
s %>%
  mutate(num_seq=read_counts/1000000) %>%
  # remove reads that did not get assigned
  ggplot(aes(x=num_seq, fill = sample_type)) +
    geom_histogram(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(s$sample_type), names(ann_geom_values$sample_type_colors))]) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Number of read pairs in sample (millions, M)",
      y="Number of samples",
      fill = "Sample Type",
      title = paste0("Total number of reads from run: ", round(sum(s$read_counts)/1000000, digits = 2), "M")
    )
```

### Number of reads per sample type

```{r reads per sample type}

s %>%
  ggplot(aes(y=read_counts, x=sample_type, fill = sample_type)) +
    geom_boxplot(outlier.alpha = 0) +
    geom_point(aes(size = sample_type), shape = 21, position = position_jitter(width = 0.2)) +
    scale_y_continuous(labels = scales::number_format(accuracy = 1)) +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(s$sample_type), names(ann_geom_values$sample_type_colors))]) +
    scale_size_manual(values = ann_geom_values$sample_type_sizes[match(levels(s$sample_type), names(ann_geom_values$sample_type_sizes))]) +
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text.x.bottom = element_text(angle = -30, hjust = 0, vjust = 0.5)) +
    labs(
      y="Read counts",
      x="", fill = "Sample Type", size = "Sample Type"
    )

```

### Percentage of reads that make up the lane

```{r percent reads of lane, echo=FALSE}
s %>%
  mutate(percent_of_lane = read_counts/sum(read_counts)) %>%
  group_by(sample_type) %>%
  mutate(tot_percent = sum(percent_of_lane)) %>%
  ungroup() %>%
  order_on_other_col(sample_type, tot_percent, decreasing = FALSE) %>%
  order_on_other_col(sample_id, percent_of_lane) %>%
  arrange(sample_id) %>%
  {
  ggplot(., aes(x = "", y = percent_of_lane, fill=sample_type)) +
    geom_col(color = "white") +
    scale_y_continuous(labels = scales::percent) +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(.$sample_type), names(ann_geom_values$sample_type_colors))]) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.ticks.x.bottom = element_blank()) +
    labs(
      x="",
      y="Percent of assigned reads by sample type",
      fill = "Sample Type"
    )
  }

```

## Top 10 unassigned indices

```{r unassigned indices}

top_unkwn_indices %>%
  ggplot(aes(y=fct_rev(index_sequence), x=number_of_reads)) +
  geom_col() +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(
      x="Number of reads",
      y="Unassigned index sequences"
  )

```

These are the adapters: \newline
`r paste0(gsub(",", ": ", unlist(sample_sheet$Settings)), collapse = "\n")`

\blandscape

## Read counts and the DNA concentration/viral values of each sample

```{r reads and CT, fig.width=10, fig.height=5, eval = has_CT}

s %>%
  filter(!is.na(CT)) %>%
  droplevels() %>%
  {
  ggplot(., aes(x = CT, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(.$sample_type), names(ann_geom_values$sample_type_colors))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "CT value", fill = "Sample type")
  }

```

```{r reads and RLU, fig.width=10, fig.height=5, eval = has_RLU}

s %>%
  filter(!is.na(RLU)) %>%
  droplevels() %>%
  {
  ggplot(., aes(x = RLU, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(.$sample_type), names(ann_geom_values$sample_type_colors))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "RLU value", fill = "Sample type")
  }

```

```{r reads and DNA, fig.width=10, fig.height=5}

s %>%
  filter(!is.na(qubit_conc_ng_ul)) %>%
  droplevels() %>%
  {
  ggplot(., aes(x = qubit_conc_ng_ul, y = read_counts, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(.$sample_type), names(ann_geom_values$sample_type_colors))]) +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "DNA conc (ng/uL)", fill = "Sample type")
  }

```

```{r CT and DNA, fig.width=10, fig.height=5, eval = has_CT}

s %>%
  filter(!is.na(CT)) %>%
  droplevels() %>%
  {
  ggplot(., aes(x = CT, y = qubit_conc_ng_ul, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(.$sample_type), names(ann_geom_values$sample_type_colors))]) +
    theme_bw() + 
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(x = "CT value", y = "DNA conc (ng/uL)", fill = "Sample type")
  }

```

```{r RLU and DNA, fig.width=10, fig.height=5, eval = has_RLU}

s %>%
  filter(!is.na(RLU)) %>%
  droplevels() %>%
  {
  ggplot(., aes(x = RLU, y = qubit_conc_ng_ul, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(.$sample_type), names(ann_geom_values$sample_type_colors))]) +
    theme_bw() + 
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(x = "RLU value", y = "DNA conc (ng/uL)", fill = "Sample type")
  }

```

\newpage

## DNA concentration and read counts values per plate

The samples are processed on a 96-well plate. These figures illustrate the viral values, DNA concentration, and read counts of each sample on a well. Wells without any samples are white while samples with low values begin with dark blue. 

```{r CT on plate, eval = has_CT}

empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  mutate(plate_col = as.numeric(plate_col)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = CT)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no covid quantity values, use the discrete fill
    {
      if(all(is.na(s$CT))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="CT values"
    )

```

```{r RLU on plate, eval = has_RLU}

empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  mutate(plate_col = as.numeric(plate_col)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = RLU)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no covid quantity values, use the discrete fill
    {
      if(all(is.na(s$RLU))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="RLU values"
    )

```

```{r DNA on plate}

empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  mutate(plate_col = as.numeric(plate_col)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = qubit_conc_ng_ul)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    #if there is no DNA concentration, use the discrete fill
    {
      if(all(is.na(s$qubit_conc_ng_ul))) scale_fill_viridis_d(na.value = "white")
      else scale_fill_viridis_c(na.value = "white")
    } +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="DNA\nconcentration\n(ng/ul)"
    )
```

```{r reads on plate}

empty_plate %>%
  merge(s, by = c("plate_coord", "plate_row", "plate_col", "plate"), all = TRUE) %>%
  filter(!is.na(plate_coord)) %>%
  droplevels() %>%
  mutate(plate = paste("Plate", plate)) %>%
  mutate(plate_col = as.numeric(plate_col)) %>%
  ggplot(aes(x=plate_col, y=fct_rev(plate_row), fill = read_counts)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    scale_fill_viridis_c(na.value = "white") +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="Raw\nread\ncounts"
    )
```

\elandscape

# Results section

DRAGEN COVID Lineage App (on BaseSpace cloud) version `r dragen_covid_lineage_version` \newline
Lineage assignment software and version `r lineage_assignment_software_version` \newline
Scorpio software version `r scorpio_software_version` \newline
Constellation database version `r constellation_version`

## Coverage

```{r coverage results}

s %>%
  filter(!is.na(median_coverage)) %>%
  droplevels() %>%
  select(sample_type, median_coverage, pct_genome_coverage_over_30x) %>%
  mutate(median_coverage = as.numeric(gsub(".$", "", median_coverage)))  %>%
  {
  ggplot(., aes(x = median_coverage, y = pct_genome_coverage_over_30x, fill = sample_type)) +
    geom_point(shape = 21, size = 3) +
    scale_y_continuous(labels=scales:::percent) +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(.$sample_type), names(ann_geom_values$sample_type_colors))]) +
      theme_classic() +
      theme(
        strip.background = element_rect(color = "white", size = 50)
        ) +
      labs(x="Median coverage", y="Percentage of genome\nwith >= 30X coverage", fill="Sample Type")
  }

```

\newpage

## Kmer results (number of unique SARS-CoV-2 fragments detected)

```{r kmer numbers}

s %>%
  ggplot(aes(x=`SARS-CoV-2`, y = `SARS-CoV-2 Unique kmers detected`, fill = sample_type)) +
    geom_boxplot(outlier.alpha = 0) +
    geom_point(aes(size = sample_type), position = position_jitterdodge(), shape = 21) +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(s$sample_type), names(ann_geom_values$sample_type_colors))]) +
    scale_size_manual(values = ann_geom_values$sample_type_sizes[match(levels(s$sample_type), names(ann_geom_values$sample_type_sizes))]) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="COVID detection",
      y="SARS-CoV-2\nkmer counts", fill = "Sample Type", size = "Sample Type"
    )

```

## Kmer results (percentage of reference SARS-CoV-2 fragments detected)

```{r COVID detection}

s %>%
  ggplot(aes(x=`SARS-CoV-2 Fraction kmers detected`, fill = sample_type)) +
    geom_histogram(binwidth=0.1, boundary=TRUE, color = "white") +
    scale_fill_manual(values = ann_geom_values$sample_type_colors[match(levels(s$sample_type), names(ann_geom_values$sample_type_colors))]) +
    scale_x_continuous(labels=scales:::percent) +
    theme_bw() + 
    theme(panel.grid = element_blank()) +
    labs(
      x="Percent of SARS-CoV-2\nfragments detected",
      y="Number of samples", fill = "Sample Type"
    )

```

## Pangolin Lineage Results

### Variant assignments from pangolin

```{r variant assignments, fig.height=9, fig.width=7}

s_toPlot %>%
  select(sample_id, lineage, sample_type) %>%
  group_by(sample_type) %>%
  mutate(fraction = 1/n()) %>%
  ungroup() %>%
  mutate(variants = fct_lump(lineage, 10, w = fraction)) %>% 
  select(-lineage) %>%
  group_by(sample_type, variants) %>%
  summarize(props = sum(fraction)) %>%
  ungroup() %>%
  mutate(variants = factor(variants, levels = names(ann_geom_values$variants))) %>%
  {
  ggplot(., aes(x=sample_type, y=props, fill=variants)) +
    geom_bar(stat="identity", position = position_fill(reverse = TRUE)) +
    facet_grid(.~sample_type, space="free", scales="free",
               labeller = labeller(.default = function(x) {gsub(" ", "\n", x)}, .multi_line = FALSE)) +
    scale_fill_manual(values = ann_geom_values$variants[match(levels(.$variants), names(ann_geom_values$variants))]) +
    scale_y_continuous(limits = c(0,1), expand=c(0,0), labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_rect(color = "white", size = 50),
      strip.text = element_text(size = 12),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      plot.title = element_text(hjust = 0.5)
      ) +
    labs(x="", y="Relative abundance", title = "Sample type", fill="Variants") +
    guides(fill = guide_legend(reverse=T, order = 1)) +
  who_legend
  }

```

\newpage

### Figure showing different pUSHER placements

```{r multiple variant assignments, fig.height=9, fig.width=8}

s_toPlot %>%
  select(sample_id, note, sample_type, nc_qc_status) %>%
  #remove "Usher placements" text in the front of note and scorpio notes
  mutate(note = gsub("^.*: |; scorpio.*", "", note)) %>%
  filter(note != "Assigned from designation hash.") %>%
  #split note into two variant columns by the space
  separate(note, into = c("variant1", "variant2"), sep = " ", extra = "merge") %>%
  mutate(variant1_prop = gsub(".*\\(|\\)", "", variant1)) %>%
  #if the notes say assigned, it means that PANGO software was used and found an exact match of the sequence to a representative lineage
  mutate(variant1_prop = gsub("Assigned from designation hash.", "1", variant1_prop)) %>%
  mutate(variant1_prop = unlist(lapply(variant1_prop, function(x) eval(parse(text=x))))) %>%
  mutate(variant2_prop = gsub(".*\\(|\\)", "", variant2)) %>%
  mutate(variant2_prop = unlist(lapply(variant2_prop, function(x) eval(parse(text=x))))) %>%
  pivot_longer(cols = c("variant1_prop", "variant2_prop"), names_to = "variant_num", values_to = "props") %>%
  mutate(variants = case_when(variant_num == "variant1_prop" ~ gsub("\\(.*", "", variant1),
                             variant_num == "variant2_prop" ~ gsub("\\(.*", "", variant2),
                             TRUE ~ NA_character_)) %>%
  filter(!is.na(props)) %>%
  mutate(variants = factor(variants, levels = names(ann_geom_values$variants))) %>%
  mutate(nc_qc_status = factor(nc_qc_status, levels = c("good", "mediocre", "bad"))) %>%
  mutate(sample_id = factor(sample_id, levels = unique(sample_id[order(variants, decreasing = FALSE)]))) %>%
  {
  ggplot(., aes(x=props, y=sample_id, fill=variants)) +
    geom_bar(stat="identity", position = position_fill(reverse = TRUE)) +
    facet_grid(nc_qc_status+sample_type~., space="free", scales="free",
               labeller = labeller(.default = start_w_newline, .multi_line = FALSE)) +
    scale_fill_manual(values = ann_geom_values$variants[match(levels(.$variants), names(ann_geom_values$variants))]) +
    scale_x_continuous(limits = c(0,1), expand=c(0,0), labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_blank(),
      strip.text.y = element_text(angle = 0, size = 6)
      ) +
    labs(y="", x="Relative abundance", fill="Variants") +
    guides(fill = guide_legend(reverse=T, order = 1)) +
  who_legend
  }

```

\newpage

### Figure showing conflicting variant assignments from pangolin, scorpio, and nextclade
Stars in boxes mean that the variants/sub-variants from different software agree

```{r conflicting assignments, fig.height=9, fig.width=8}

s_toPlot %>%
  select(sample_id, lineage, scorpio_lineage, Nextclade_pango, sample_type, nc_qc_status) %>%
  rename(Scorpio = "scorpio_lineage", Pangolin = "lineage", NextClade = "Nextclade_pango") %>%
  rowwise() %>%
  mutate(sp = grepl(Scorpio, Pangolin) | grepl(Pangolin, Scorpio)) %>%
  mutate(sn = grepl(Scorpio, NextClade) | grepl(NextClade, Scorpio)) %>%
  mutate(pn = grepl(Pangolin, NextClade) | grepl(NextClade, Pangolin)) %>%
  mutate(sp = ifelse(is.na(sp), FALSE, sp), sn = ifelse(is.na(sn), FALSE, sn), pn = ifelse(is.na(pn), FALSE, pn)) %>%
  pivot_longer(cols = c("Pangolin", "Scorpio", "NextClade"), names_to = "software", values_to = "variants") %>%
  mutate(uniq = case_when(pn & grepl("Pangolin|NextClade", software) ~ "*",
                          sn & grepl("Scorpio|NextClade", software) ~ "*",
                          sp & grepl("Scorpio|Pangolin", software) ~ "*",
                          TRUE ~ "")) %>%
  mutate(software = factor(software, levels = c("Scorpio", "Pangolin", "NextClade"))) %>%
  mutate(variants = factor(variants, levels = names(ann_geom_values$variants))) %>%
  mutate(nc_qc_status = factor(nc_qc_status, levels = c("good", "mediocre", "bad"))) %>%
  mutate(sample_id = factor(sample_id, levels = unique(sample_id[order(variants, decreasing = FALSE)]))) %>%
  {
  ggplot(., aes(x=software, y=sample_id, fill=variants, label=uniq)) +
    geom_tile(stat="identity") +
    geom_text() +
    facet_grid(nc_qc_status+sample_type~., space="free", scales="free",
               labeller = labeller(.default = start_w_newline, .multi_line = FALSE)) +
    scale_fill_manual(values = ann_geom_values$variants[match(levels(.$variants), names(ann_geom_values$variants))]) +
    theme_classic() +
    theme(
      strip.background = element_blank(),
      strip.text.y = element_text(angle = 0, size = 6),
      axis.text.x.bottom = element_text(angle = -30, hjust = 0, vjust = 0.5)
      ) +
    labs(y="", x="Software used to determine variants", fill="Variants") +
    guides(fill = guide_legend(reverse=T, order = 1)) +
  who_legend
  }

```

```{r lineage and VOC checks}

has_pos_ctrl <- s %>%
  filter(grepl("Mock DNA", sample_type)) %>%
  mutate(is_pos = lineage == "B") %>%
  select(is_pos) %>%
  pull()

not_same_VOCs <- s %>%
  mutate(compare = nc_VOC != scorpio_call) %>%
  filter(!is.na(compare)) %>%
  select(compare) %>%
  pull() %>%
  sum()

```

`r if(!has_pos_ctrl | is.na(has_pos_ctrl)){paste0("\\textcolor{red}{\\huge Positive control is not correct lineage}")}`

`r if(not_same_VOCs > 0){paste0("Number of NextClade VOC and scorpio constellation mismatches: ", not_same_VOCs)}`

## Nextclade

### Coverage and QC scores

```{r nextclade coverage, fig.height=9, fig.width=7}

s_toPlot %>%
  select(sample_type, median_coverage, pct_genome_coverage_over_30x, nc_qc_status) %>%
  filter(!is.na(median_coverage)) %>%
  mutate(median_coverage = as.numeric(gsub(".$", "", median_coverage))) %>%
  mutate(nc_qc_status = factor(nc_qc_status, levels = c("good", "mediocre", "bad"))) %>%
  {
  ggplot(., aes(x = nc_qc_status, y = pct_genome_coverage_over_30x)) +
    geom_hline(slope = 0, yintercept = 0.8, color = "grey", linetype = "dotted", lwd=0.75) +
    geom_boxplot(outlier.alpha = 0) +
    geom_point(aes(fill = median_coverage, shape = sample_type), position = position_jitterdodge(), size = 3) +
    scale_shape_manual(values = ann_geom_values$sample_type_shapes[match(levels(.$sample_type), names(ann_geom_values$sample_type_shapes))]) +
    scale_fill_viridis_c() +
    scale_y_continuous(labels=scales:::percent) +
    theme_classic() +
    theme(
      strip.background = element_rect(color = "white", size = 50)
    ) +
    labs(x="NextClade QC Status", y="Percentage of genome\nwith >= 30X coverage", fill = "Median\nCoverage (X)", shape = "Sample Type")
  }

```

## Summary of variants
Percentages of variants only in samples that meet criteria (Pangolin results)

```{r percent table}

s_toPlot %>%
  filter4report() %>%
  mutate(all_samples_n = n()) %>%
  select(lineage, scorpio_call, sample_type, all_samples_n) %>%
  group_by(sample_type, scorpio_call, lineage) %>%
  summarise(variant_percentages = n()/all_samples_n*100) %>%
  mutate(variant_percentages_text = paste0(round(variant_percentages, digits = 2), "\\%")) %>%
  ungroup() %>%
  arrange(-variant_percentages) %>%
  select(-variant_percentages) %>%
  unique() %>%
  kable("latex", longtable = F, digits=2, booktabs=T, escape=F,
        col.names = linebreak(c("Sample Type", "WHO", "Variant", "Variant\npercentage"), align = "l")) %>%
  kable_styling(latex_options = c("scale_down", "repeat_header", "HOLD_position")) %>%
  row_spec(0, bold = T, color="#7C0A02") %>%
  collapse_rows(columns = 1:2, valign = "top")

```


```{r data export}

dir.create(here("upload", "epi"), recursive = TRUE)
dir.create(here("upload", "seqsender"), recursive = TRUE)

# Export the data for EPI's
epi_report <- s_toPlot %>%
  filter4report() %>%
  select(sample_name, sample_collected_by, sequencing_date, lineage, scorpio_call) %>%
  arrange(sample_collected_by, sample_name) %>%
  rename(accession_number = "sample_name", who_label = "scorpio_call")

epi_report %>%
  write_csv(epi_report_fp)

# Export the data for seqsender upload to sra, genbank, and gisaid
seqsender <- s_toPlot %>%
  filter4report() %>%
  mutate(genbank_name = paste0("SARS-CoV-2/USA/", sample_id, "/", str_sub(project_name, 1, 4))) %>%
  mutate(sra_name = paste0("SARS-CoV-2/USA/", sample_id)) %>%
  mutate(gisaid_name = paste0("hCoV-19/USA/", sample_id, "/", str_sub(project_name, 1, 4))) %>%
  mutate(collection_date = case_when(!is.na(sample_collection_date) ~ sample_collection_date,
                                     !is.na(PHL_sample_received_date) ~ PHL_sample_received_date,
                                       TRUE ~ sequencing_date)) %>%
  mutate(location = "USA: PA",
         gisaid_location = "North America/USA/Pennsylvania",
         zip = "19146",
         type = "betacoronavirus",
         passage = "Original") %>%
  mutate(gender = ifelse(is.na(gender), "Unknown", gender)) %>%
  rename(isolation_source = "sample_type",
         host = "host_scientific_name",
         sex = "gender",
         collected_by = "sample_collected_by",
         orig_lab = "sample_collected_by") %>%
  mutate(gisaid_age = "Unknown",
         gisaid_age_range = paste0("Age: ", host_age_bin),
         patient_status = "Unknown",
         instrument = paste0("Illumina ", instrument_type),
         library = "ARTIC Network Protocol V4",
         assembly_method = paste0("DRAGEN COVID Lineage ", dragen_covid_lineage_version),
         library_strategy = "AMPLICON",
         library_source = "VIRAL RNA",
         library_selection = "RT-PCR",
         library_layout = "PAIRED",
         structured_comment = "Assembly-Data") %>%
  mutate(orig_lab_address = casewhen(sample_collected_by == "Philadelphia Department of Public Health" ~ "500 South Broad Street, Philadelphia, PA 19146 USA",
                                     sample_collected_by == "Temple University" ~ "1801 North Broad Street, Philadelphia, PA 19122 USA",
                                      TRUE ~ "Unknown")) %>%
  mutate(sra_file_path_1 = here("upload", "fastq", paste0(sample_id, "_S", SampleNumber, "_L00", lane, "_R1_001.fastq.gz"))) %>%
  mutate(sra_file_path_2 = here("upload", "fastq", paste0(sample_id, "_S", SampleNumber, "_L00", lane, "_R2_001.fastq.gz"))) %>%
  mutate(design_description = paste0("Viral sequencing was performed following a tiling amplicon strategy using the ARTIC V4 primer scheme. Sequencing was performed using the Illumina MiSeq instrument with 2x", read_length, " bp chemistry. Libraries were prepared using Illumina COVIDSeq Test kit.")) %>%
  select(sample_id, genbank_name, sra_name, gisaid_name, collection_date, location, gisaid_location, zip, type, passage, organism,
         isolation_source, host, host_disease, host_age_bin, gisaid_age, gisaid_age_range, sex, patient_status, 
         instrument, library, assembly_method, library_strategy, library_source, library_selection, library_layout, structured_comment, median_coverage, design_description,
         collected_by, orig_lab, orig_lab_address, sra_file_path_1, sra_file_path_2)

seqsender %>%
  write_csv(seqsender_meta_fp)

#double checking to see if number of samples match
n_samples_report <- s %>%
  filter(!grepl("None|Undetermined", sample_id)) %>%
  filter(!grepl("control", sample_type, ignore.case = TRUE)) %>%
  filter(!is.na(lineage)) %>%
  filter(!is.na(nc_qc_status)) %>%
  filter(nc_qc_status != "bad") %>%
  filter(!(nc_qc_status == "mediocre" & pct_genome_coverage_over_30x < .8)) %>%
  filter(pango_qc_status != "fail") %>%
  nrow()

```

```{r final check}

csvs_2_upload <- list.files(here("upload"), pattern = ".csv", recursive = TRUE, full.names = TRUE)

#should be 2 sets of sample_ids here (from epi report and seqsender csv)
all_sample_ids_from_csv <- csvs_2_upload %>%
  data_frame(FileName = .) %>%
  group_by(FileName) %>%
  do(read_csv(.$FileName, col_names = FALSE)) %>%
  ungroup() %>%
  select(FileName, X1) %>%
  mutate(file = gsub(".*/", "", FileName)) %>%
  filter(!grepl("sample_id|sample_name", X1)) %>%
  mutate(X1 = gsub(".*/USA/|/.*", "", X1)) %>%
  merge(select(s, sample_id, sample_name), by.x = "X1", by.y = "sample_name", all.x = TRUE) %>%
  mutate(sample_id = ifelse(is.na(sample_id), X1, sample_id)) %>%
  select(-c(FileName, X1))

#should be 1 set here
fastq_2_upload <- list.files(here("upload", "fastq"), pattern = ".fastq.gz", recursive = TRUE, full.names = TRUE) %>%
  data.frame(FileName = .) %>%
  mutate(sample_id = gsub(".*upload/fastq/|_S[0-9].*_L001_R[12]_001.fastq.gz$", "", FileName)) %>%
  mutate(file = gsub(".*/", "", FileName)) %>%
  select(-FileName)

fastq2_compare <- fastq_2_upload %>%
  filter(grepl("_L001_R1_001.fastq.gz", file))

if (nrow(fastq_2_upload)/2 != nrow(fastq2_compare)) {
  stop (simpleError("Missing some fastq files!"))
}

#should be 1 set here
fasta_samples <- read_csv(here("upload", "fasta", paste0(project_name, "_PHL2_combined.fasta")), col_names = FALSE) %>%
  filter(grepl("^>", X1)) %>%
  mutate(sample_id = gsub("^>", "", X1)) %>%
  mutate(file = paste0(project_name, "_PHL2_combined.fasta")) %>%
  select(-X1)

check_all <- all_sample_ids_from_csv %>%
  rbind(fastq2_compare) %>%
  rbind(fasta_samples) %>%
  group_by(sample_id) %>%
  mutate(count_all_samples = n()) %>%
  ungroup()

#can change this to 3 if you don't want to check the fastq files
if (!all(check_all$count_all_samples == 4)) {
  stop (simpleError("Some files are missing samples to upload!"))
}

#these are samples that failed in the pipeline for whatever reason. Can rerun pipeline to generate results for these samples
rerun_samples <- s %>%
  filter(is.na(`SARS-CoV-2 Fraction kmers detected`)) %>%
  select(sample_id) %>%
  pull()

```

\newpage

# Appendix

## Number of reads before and after filtering
Red samples refer to results that will not be reported (controls or no lineage results) \newline
Orange samples also refer to results that will not be reported (bad or mediocre NextClade QC with <80% 30X coverage) \newline
The total number of samples with acceptable results for reporting is `r n_samples_report` out of `r nrow(s[grepl("Nasal swab", s$sample_type), ])` nasal samples sequenced. \newline
Number of samples to send to epidemiologists: `r nrow(epi_report)` \newline
Number of samples to upload to GISAID database: `r nrow(gisaid)` \newline
Number of samples to upload to SRA and number of BioSamples to create: `r nrow(bio_sample)` and `r nrow(sra)`\newline

`r if(length(rerun_samples) > 0) { paste0("\\textcolor{red}{\\huge There are samples that didn't go through the pipeline correctly!}")}`

```{r trimmed reads, echo=FALSE}

s %>%
  arrange(-read_counts) %>%
  mutate(sample_id = cell_spec(sample_id, "latex",
                               color = case_when((grepl(paste0(rerun_samples, collapse = "|"), sample_id) & length(rerun_samples) > 0) ~ "yellow",
                                                 ((grepl("control|Unassigned reads", sample_type)) | (!(sample_id %in% s_toPlot$sample_id))) ~ "red",
                                                 ((grepl("bad", nc_qc_status)) | (grepl("mediocre", nc_qc_status) & pct_genome_coverage_over_30x < .8) | (grepl("fail", pango_qc_status))) ~ "orange",
                                                 TRUE ~ "black"))) %>%
  select(sample_id,
         sample_type,
         total_raw_reads,
         read_counts) %>%
  kable_style()

```

\blandscape

# Review and Approval

```{r sign off}

data.frame(`Role and Name` = linebreak(c("Bioinformatician:\nVincent Tu, PhD",
                                         "Sequencing Manager:\nMazen Sid Ahmed, PhD",
                                         "Laboratory Directory:\nBernadette Matthis, MSBA"), align = "l"),
           Signature = c("", "", ""),
           Date = c(as.character(Sys.Date()), "", ""), check.names = FALSE) %>%
  kable_style() %>%
  #add signatures in the second column
  column_spec(2, image = spec_image(c(tag, blank, blank), width = 500, height = 180))

```

\elandscape

```{r Generate time stamped report, eval=FALSE, include=FALSE}

library(here)
rstudioapi::documentSaveAll()
dir.create(here("output"))
project_name <- basename(here())

qc_report_fp <- paste0(project_name, "_QC_Report.Rmd")
qc_output_fp <- here("output", paste0(project_name, '.QC.report_gen.on.', Sys.Date(), '.pdf'))

# need to download and import basespace data for each sample?
dl_bs_data <- TRUE

# need to import the data into a single tsv?
import_data <- TRUE

rmarkdown::render(qc_report_fp, output_file = qc_output_fp)

dl_bs_data <- FALSE
import_data <- FALSE
rmarkdown::render(qc_report_fp, output_file = "README.md",
                 output_format = rmarkdown::md_document(variant = "markdown_github", toc = TRUE))

```

```{r run R script, eval=FALSE, include=FALSE}

#copy files if this script exists
tryCatch(
  {
    source(file.path(dirname(here()), "cp2admin.R"))
  }, error = function(e)
  {

  }
)

```

```{r upload data if results look good, eval=FALSE, include=FALSE}

#intialize data_upload conda env
use_condaenv("seqsender", required = TRUE)
import("os")

test_upload <- TRUE #change this to FALSE when SRA upload and gisaid upload tests are successful

if(test_upload) {
  upload_test_flag <- "--test"
} else{
  upload_test_flag <- ""
}

use_proxy <- TRUE #change this to FALSE to not use proxy

if(use_proxy) {
  proxy_setting <- "--proxy"
} else{
  proxy_setting <- ""
}

### prepare files to upload
system2("python", args = c("seqsender.py", proxy_setting, "prep",
                           "--unique_name", project_name,
                           "--config", seqsender_config_fp,
                           "--metadata", seqsender_meta_fp,
                           "--fasta", fasta_fp,
                           upload_test_flag)

### submit files to biosample and sra
system2("python", args = c("seqsender.py", proxy_setting, "submit",
                           "--unique_name", project_name,
                           "--config", seqsender_config_fp,
                           "--metadata", seqsender_meta_fp,
                           "--fasta", fasta_fp,
                           upload_test_flag)
        
### submit files to genbank
system2("python", args = c("seqsender.py", proxy_setting, "submit",
                           "--unique_name", project_name,
                           "--config", seqsender_config_fp,
                           "--metadata", seqsender_meta_fp,
                           "--fasta", fasta_fp,
                           upload_test_flag)
        
### submit files to gisaid
system2("python", args = c("seqsender.py", proxy_setting, "gisaid",
                           "--unique_name", project_name,
                           "--config", seqsender_config_fp,
                           upload_test_flag)


```
