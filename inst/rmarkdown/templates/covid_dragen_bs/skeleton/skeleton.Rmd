---
title: |
  ![](forKnitting/logo_blk.png){width=5in}  
  "`r paste0('QC report for ', gsub("_", " ", basename(here())))`"
author: "PennCHOP Microbiome Program"
date: \today
geometry: margin=3cm
output: 
    pdf_document:
        template: forKnitting/toc_after.tex
        keep_tex: false
        toc: true
        toc_depth: 3
        includes:
            in_header: forKnitting/TeX_packages_commands.sty

---

\tableofcontents

<!-- ========================================================== -->
<!--   Beginning of Preamble : Preamble seldom requires change  -->
<!-- ========================================================== -->

```{r setup, echo=FALSE}
### ================
###   knitr setup
### ================
library(knitr)
opts_chunk$set(
  tidy=FALSE,
  cache=FALSE,
  cache.lazy = FALSE,
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  dpi=100,
  fig.width=7,
  fig.height=8,
  fig.align = "center",
  dev.args = list(pdf = list(useDingbats = FALSE))
  )

pander::panderOptions("knitr.auto.asis", FALSE)
#this also means that you have to put results='asis' in any block that has pander output
#this lets you loop through variables and produce multiple pander tables and ggplots in a
#single code block!

```

```{r child = 'Rmd/preamble.Rmd'}
```


```{r, Samples error check 1}
### ===========================
###   check for missing samples
### ===========================

### possible issue 1: Samples found in the sample sheet but not in the feature table (0 reads)
s_missing <- s %>%
  filter(!SampleID %in% colnames(cts)) %>%
  select(SampleID, sample_type, isControl)

if (any(!s_missing$isControl)) {
  pander(filter(s_missing, !isControl), caption="These samples were in the sample sheet but not in the feature table.")
  #stop (simpleError("Please fix"))
}

```


```{r, Samples error check 2}
### possible issue 2: Samples found in the feature table but not in the sample sheet. There must be an error!
in_counts_not_in_s <- setdiff(colnames(cts), s$SampleID)
if (length(in_counts_not_in_s) > 0) {
  stop (simpleError("These SampleID(s) are in the feature table, but not found in the sample sheet.", paste(in_counts_not_in_s, collapse=" ")))
}
```

\newpage

# Introduction

This report is based on the results of sequencing performed on `r run_date` for `r investigator`

# Demultiplexing and quality control

## Number of read pairs per sample after demultiplexing

Samples were sequenced on Hiseq 2500 and demultiplexed. The demultiplexing step involves matching the barcode sequences associated with each sample to the sequence each read is tagged with.

```{r reads_histogram, echo=FALSE, fig.width=6, fig.height=6}
s %>%
  mutate(num_seq=input/1000000) %>%
  ggplot(aes(x=num_seq)) +
    geom_histogram(aes(fill=sample_type), binwidth=1, boundary=TRUE) +
    theme_bw() + 
    labs(
      x="Number of read pairs in sample (millions, M)",
      y="Number of samples"
    )
#ggsave(filename="read_qc.pdf", width=7, height=5, useDingbats=F)
```

\newpage

## Average nucleotide quality after adapter trimming and quality control

Nextera-XT adapters were removed using trimmomatic-0.33. Nucleotide quality for each position was averaged across all reads using FASTQC.

```{r fastqc, echo=FALSE, fig.width=6, fig.height=7}

qc_df <- read.delim(fastqc_fp, sep='\t') %>%
  melt(id.vars="Samples", variable.name="Position", value.name = "Quality") %>%
  mutate(
    Position = sub("X", "", Position),
    Position = sub("\\.\\d+", "", Position, perl = TRUE),
    Position = as.numeric(Position)) %>%
  mutate(SampleID=sub("^(.*)_([12])$", "\\1", Samples), Direction=sub("^(.*)_([12])$", "\\2", Samples)) %>%
  mutate(Direction = factor(Direction)) %>%
  group_by(Direction, Position) %>%
  summarise(MeanQual = mean(Quality), SdQual = sd(Quality)) %>%
  mutate(LowQual = MeanQual - SdQual, HighQual = MeanQual + SdQual) %>%
  ungroup()


qc_df %>%
  ggplot(aes(x=Position, y=MeanQual)) + 
    geom_errorbar(aes(ymin=LowQual, ymax=HighQual), lwd=0.25) +
    facet_wrap(~ Direction) +
    geom_line(size=0.25) +
    geom_point(size=1) +
    theme_bw() + 
    labs(x='Position in sequence read', y='Average quality score per sample')
#ggsave(filename='quality_after_trim.pdf', width=7, height=5, useDingbats=F)
```

\newpage

\blandscape

## Overall distribution of percentage reads removed in quality control

The low quality reads defined by Trimmomatic-0.33 were discarded from further analysis. Human DNA was filtered using BWA with HG38 version of human genome as reference. Reads mapping to the PhiX genome was also removed. Only the reads tagged as non-human were further analyzed.

```{r preprocess, echo=FALSE, fig.width=10, fig.height=5}
s %>%
  rbind(s) %>%
  mutate(low_quality = (input - host - nonhost) / input) %>%
  mutate(human = host / input) %>%
  mutate(non_human = nonhost / input) %>%
  ##can comment out this line after checking control quality as well
  #filter(!isControl) %>%
  arrange(desc(human)) %>%
  mutate(Sample_num=row_number()) %>%
  melt(c("Sample_num", quality_by), c("low_quality", "human", "non_human")) %>%
  ggplot(aes(x=Sample_num, y=value)) +
    geom_area(aes(fill=variable), position='stack') + 
    facet_grid(.~eval(parse(text=quality_by)), scales = "free_x") +
    scale_fill_brewer(palette="Set1") + 
    theme(axis.text.x = element_blank(), axis.ticks = element_blank()) +
    scale_x_continuous(expand=c(0,0)) +
    scale_y_continuous(expand=c(0,0), labels=scales:::percent) +
    labs(x="Samples", y="Percentage of reads", fill="")
#ggsave(filename='preprocess_summary.pdf', width=5, height=7, useDingbats=F)
```

\newpage
## Read counts and final library concentration of each sample

```{r, fig.width=10, fig.height=5}

s %>%
  mutate(Read_Counts = ifelse(is.na(nonhost), 0, nonhost)) %>%
  droplevels() %>%
  ggplot(aes(x = final_library_conc_ng_ul, y = Read_Counts, fill = sample_type)) +
    geom_point(shape = 21) +
    geom_hline(yintercept = min_reads, color="black", linetype="dashed") +
    theme_bw() + 
    scale_y_continuous(trans = "log10") +
    guides(fill = guide_legend(override.aes = list(shape = 21))) +
    labs(y = "Read Counts", x = "Final library DNA conc (ng/uL)")

```
\newpage
## Library concentration and read counts per plate

The samples are processed on a 96-well plate. The figures illustrate the library concentration, read counts after demultiplexing and read counts after quality control / denoising steps for each well. The gray color represents NA values. 

```{r}
s %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_column, y=fct_rev(plate_row), fill = final_library_conc_ng_ul)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    scale_fill_viridis_c() +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="Library\nconcentration\n(ng/ul)"
    )
```

```{r}
s %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_column, y=fct_rev(plate_row), fill = input)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    scale_fill_viridis_c() +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="Raw\nread\ncounts"
    )
```


```{r}
s %>%
  mutate(plate = paste("Plate", plate)) %>%
  ggplot(aes(x=plate_column, y=fct_rev(plate_row), fill = nonhost)) +
    geom_tile(fill = "white") +
    geom_point(shape = 21, size = 10) +
    facet_wrap(~plate, ncol = 1) +
    scale_fill_viridis_c() +
    scale_x_continuous(breaks=seq(1,12), expand=c(0,0), limit = c(0, 13), position = "top") +
    theme_bw() +
    theme(
      strip.background = element_blank(),
      strip.placement = "outside",
      panel.grid = element_blank(),
      aspect.ratio = 0.66
    ) +
    labs(
      x="",
      y="Plate row",
      fill="QC\nread\ncounts"
    )
```

\elandscape

\newpage

# Taxonomic assignments

```{r heatmap_assignments}

satu_limit <- 0.4
heatmap_file <- paste(Sys.Date(), "_taxonomy_heatmap.pdf", sep='')
heatmap_fp <- here("output", "basic_report", heatmap_file)

```

Taxonomic assignments were performed using the Kraken program.

Heatmap charts were generated from the taxonomic assignments. Each column represents one sample and each row represents one taxon (typically a species). Ranks are included in the plot if the taxon is present in `r 100*prop_cut`% abundance in at least one sample.

The chart is colored white if species were not observed in the sample, dark blue if species were observed at very low abundance.  This allows the reader to quickly survey species presence/absence.  Abundance values exceeding `r 100*satu_limit`% are colored red, indicating an extremely dominant species.

Please note: only bacterial results are shown.\
`r if(show.text){paste0("Please see attached plot ", heatmap_file, " for the full heatmap")}`

```{r heatmap time, fig.height=10, fig.width=10}

# select taxa with mean relative abundance of prop_cut in at least one sample type
select_taxa <- summed_props %>%
  as.data.frame() %>% 
  rownames_to_column("Taxa") %>% 
  filter(!grepl("phage|sapiens", Taxa)) %>%
  pivot_longer(-Taxa, names_to="SampleID", values_to="props") %>%
  right_join(s_toPlot, by="SampleID")  %>%
  group_by(sample_type, Taxa) %>%
  mutate(mean_prop = mean(props)) %>%
  ungroup() %>%
  filter(mean_prop > prop_cut) %>%
  mutate(phyla = gsub(" .*", "", Taxa)) %>%
  mutate(phyla = factor(phyla, levels = unique(phyla))) %>%
  mutate(phyla = fct_relevel(phyla, "Actinobacteria",
                                    "Bacteroidetes",
                                    "Firmicutes",
                                    "Proteobacteria",
                                    "Verrucomicrobia")) %>%
  arrange(phyla) %>%
  pull(Taxa) %>%
  as.character() %>%
  unique()

summed_props[select_taxa, s_toPlot$SampleID] %>%
  pheat() %>%
  pheat_color_saturated(saturation_limit = satu_limit) %>%
  pheat_annotate_cols(s_toPlot[, c("SampleID", quality_by, shape_by)]) %>%
  pheat_display_cols(gaps = factor_gaps(s_toPlot[, quality_by])) %>%
  #using if statement here because ifelse is vectorized
  #have to include brackets around if statement otherwise if will always be true (1 is passed)
  {`if`(show.text, pheat_save(., heatmap_fp), .)}

### top species
# top <- top_table(summed_props[select_taxa, s_toPlot$SampleID], s_toPlot, option=2, prop_cut = prop_cut)
# 
# top$avg_prop <- apply(top,1,mean)
# 
# top <- top %>%
#   rownames_to_column() %>%
#   rename(Taxa = rowname) %>%
#   filter(!row.names(top) %in% c("g__; s__")) %>%
#   mutate(Taxa = gsub("g__","",Taxa)) %>%
#   mutate(Taxa = gsub("; s__"," ", Taxa)) %>%
#   arrange(desc(avg_prop))

```

\newpage

The chart below is a taxonomic heatmap for the negative and positive control samples. The experimental samples are averaged per sample type. Only the taxa with a mean relative abundance of `r 100*prop_cut`% are shown.

```{r fig.height=10, fig.width=10}

# select taxa with mean relative abundance of 1% in at least one sample type
sample_type_averages <- summed_props %>%
  as.data.frame() %>% 
  rownames_to_column("Taxa") %>% 
  pivot_longer(-Taxa, names_to="SampleID", values_to="props") %>%
  right_join(s_toPlot, by="SampleID")  %>%
  filter(!isControl) %>%
  group_by(sample_type, Taxa, isControl) %>%
  summarize(props = mean(props)) %>%
  ungroup() %>%
  mutate(SampleID=sample_type)

controls <- summed_props %>%
  as.data.frame() %>% 
  rownames_to_column("Taxa") %>% 
  pivot_longer(-Taxa, names_to="SampleID", values_to="props") %>%
  right_join(s_toPlot, by="SampleID")  %>%
  filter(isControl) 

ctrl_df <- bind_rows(sample_type_averages, controls) %>%
  group_by(Taxa) %>%
  mutate(mean_prop = mean(props)) %>%
  ungroup() %>%
  filter(mean_prop > prop_cut) %>%
  mutate(phyla = gsub(" .*", "", Taxa)) %>%
  mutate(phyla = factor(phyla, levels = unique(phyla))) %>%
  mutate(phyla = fct_relevel(phyla, "Actinobacteria",
                                    "Bacteroidetes",
                                    "Firmicutes",
                                    "Proteobacteria",
                                    "Verrucomicrobia")) %>%
  arrange(phyla) %>%
  select(-phyla) %>%
  mutate(is_control = ifelse(isControl, "Control samples", "Non-control samples")) %>%
  arrange(is_control, SampleID)

ctrl_df %>%
  select(SampleID, Taxa, props) %>%
  pivot_wider(names_from=SampleID, values_from=props) %>%
  pheat(rownames_in="Taxa") %>%
  pheat_annotate_cols(unique(ctrl_df[, c("SampleID", "is_control")])) %>%
  pheat_color_saturated(saturation_limit = satu_limit) %>%
  pheat_display_cols(gaps = factor_gaps(unlist(unique(ctrl_df[ c("SampleID", "is_control")]) %>% select(is_control))))

```

`r if(!has_pos_ctrl){paste0("\\textcolor{red}{\\huge THERE IS NO VIBRIO IN THE POSITIVE CONTROLS}")}`

\newpage

# Beta diversity

## Bray-Curtis distance

### PCoA plot based on Bray-Curtis distance

Here, we use Bray-Curtis distance to compare the species composition of the samples to each other.

The first plot shows the distance between each pair of samples in a single 2D plot.  It is not possible to plot the distances exactly on paper, so we have used a method of ordination called Principal Coordinates Analysis to select the best coordinate system for display.  The percentage of total variance captured along each axis is displayed on the chart.

```{r bray-curtis, fig.height=5, fig.width=7}

s_toPlot %<>%
  filter(Keep) %>%
  filter(!isControl) %>%
  droplevels()

dist_in <- usedist::dist_subset(bc, s_toPlot$SampleID)
plot(make_pcoa_plot(dm = dist_in, s = s_toPlot, color_by=color_by, shape_by=quality_by))

#manual
#plot(make_pcoa_plot(dist_in, s_toPlot, color_by="sample_type", shape_by="expected_genus"))
```

\newpage

## Jaccard distance

Here, we use Jaccard distance to compare samples based on shared species membership.  Plots are described above.

### PCoA plot based on Jaccard distance

```{r jaccard, fig.height=5, fig.width=7}

dist_in <- usedist::dist_subset(jd, s_toPlot$SampleID)
plot(make_pcoa_plot(dist_in, s_toPlot,  color_by=color_by, shape_by=quality_by))
```

\newpage

# Contamination analysis

Now that we have shown some basic statistics and visulazations of all the samples we will see how they compare to one another in terms of the differenct variables and their effect on the taxonomic abundances.

---

*How to read the results tables*

Taxa is the species / genera / family / other taxonomic level in question.

term is the predictive variable(s) in question.

Value is the predicted change in logit transformed abundance due to the predictive variable(s).

Standard error is a measure of variability of said Value.

DF is the degrees of freedom. As we add more terms to the linear model, the degrees of freedom decreases. 

t.value is the output of the t-test of the changes in abundance by the predictive variable(s).

p.value is the probabability that we can reject the null hypothesis that there is no change in the abundance due to the variables. The null hypthosesis, expressed another way, is the scenario where the coefficients of all predictive variables are 0; thus, the outcome variable equals the intercept in the linear model.

fdr is the false-detection rate. It is a p.value adjusted for the multiple t-tests being conducted at once on all Taxa above 1% mean abundance.

---

But first, we will check for common contaminants in the non-control samples:

## Linear model analysis

Contaminant taxa tend to correlate with increased dna concentration negatively (i.e. the more total bacteria, the less likely a contaminant will be abundant).

### Plot of `final_library_conc_ng_ul` against taxa abundances.

\blandscape

```{r linear model, fig.width=10, fig.height=6}

#############
#Section to show DNA contamination
#If no significant contaminant, don't show this section
#############

##get Taxa that are greater than 1% in more than 60% of all samples
rows_to_keep <- filter_low_coverage(summed_props, min_ab = 0.01)

summed_props[rows_to_keep,] %>%
  as.data.frame() %>%
  rownames_to_column(var = "Taxa") %>%
  gather(key = "SampleID", value = "Prop", s_toPlot$SampleID) %>%
  fix_zeros_v2(Prop) %>%
  merge(s_toPlot, by="SampleID") %>%
  #view()
  mutate(Taxa = sub(" ", "\n", Taxa)) %>%
  mutate(Taxa = reorder(Taxa, -Prop)) %>%
  rename(DNA_concentration = "final_library_conc_ng_ul") %>%
  ggplot(aes(x=DNA_concentration, y=Prop)) +
    geom_point(aes(color = sample_type)) +
    geom_smooth(method = "lm") +
    theme_bw() +
    theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1),
          axis.text.y=element_text(size=5),
      strip.background = element_blank()) +
    scale_color_brewer(palette = "Set2") +
    scale_y_continuous(trans = "logit") +
    facet_wrap(~Taxa, scales="free_y", ncol=3) +
    labs(x="DNA_concentration (ng/uL)", color="Sample Type",
         y="Relative abundance",
         title = paste("Scatterplot of DNA concentration vs. Taxa abundance"))

```

\elandscape

### Linear models for possible contaminants

We will now test for significance of that association.


```{r possible contaminants, results='asis'}

##basic linear model to see if counts correlate with dna concentration (no need to get props)

form1 <- "props_log ~ final_library_conc_ng_ul"

summaries_df <- run_lm(summed_props[rows_to_keep,], s_toPlot, form1, 0.05)

summaries_df %>%
  mutate(term = gsub("final_library_conc_ng_ul", "DNA_concentration", term)) %>%
  get_fdr(term) %>%
  kable_sort(term) %>%
  filter(term != '(Intercept)') %>%
  kable_style()

```

\newpage

# Appendix

## Number of reads before and after trimmming Illumina adapter sequences with Trimmomatic.

```{r trimmed reads, echo=FALSE}

preprocess %>%
  merge(select(s, SampleID, sample_type), by = "SampleID", all.x = TRUE) %>%
  arrange(-both_kept) %>%
  select(SampleID,
         sample_type,
         Input = input,
         Dropped = dropped,
         `Both kept` = both_kept) %>%
  kable_style()
```

\newpage

## Number of reads before and after filtering of host genome sequence.

```{r filtered reads, echo=FALSE}
preprocess %>%
  merge(select(s, SampleID, sample_type), by = "SampleID", all.x = TRUE) %>%
  mutate(`Percent host reads` = 100 * host / (host + nonhost),
    `Percent host reads` = round(`Percent host reads`, 2)) %>%
  arrange(`Percent host reads`) %>%
  select(SampleID,
         sample_type,
        `Host reads` = host,
        `Non-host reads` = nonhost,
        `Percent host reads`) %>%
  kable_style()
```


```{r Generate time stamped report, eval=FALSE, include=FALSE}
#notes
#neat: you can run this following command in the console to give your reports custom names (or date-stamp them)
#rmarkdown::render('ronen_stein_Report_shotgun.Rmd',output_file = paste('CEASE.report.', Sys.Date(), '.pdf', sep=''))
library(here)
rstudioapi::documentSaveAll()
dir.create(here("output", "basic_report"))

sequencing_run_date <- gsub("_.*", "", basename(here()))
project_name <- sub("^([^_]+)_", "", basename(here()), perl = TRUE)

qc_report_fp <- here(paste(sequencing_run_date, "_" , project_name, "_QC_Report.Rmd", sep=""))
qc_output_fp <- here("output", "basic_report", paste(project_name, '.QC.report.', Sys.Date(), '.pdf', sep=''))

basic_report_fp <- here("Rmd", "basic_report.Rmd")
basic_output_fp <- here("output", "basic_report", paste(project_name, '.basic.report.', Sys.Date(), '.pdf', sep=''))

rmarkdown::render(qc_report_fp, output_file = qc_output_fp, "all")
rmarkdown::render(basic_report_fp, output_file = basic_output_fp, "all")

```



